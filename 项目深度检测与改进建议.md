# 项目深度检测与改进建议

本报告基于提供的项目结构与源码进行架构健壮性、异常路径与用户体验的深度检测；不涉及安全类问题。证据处均提供可点击代码定位。

## 范围与方法
- 代码走查：后端任务流、Redis 消息、WebSocket、前端 WS 客户端
- 异常场景推演：进程崩溃、代理失败、网络抖动、客户端关闭/刷新
- 可观测性评估：日志、事件序列、状态恢复能力

## 结论概要（Top Risks）
| 风险 | 影响 | 证据 | 建议 | 严重性 |
|---|---|---|---|---|
| 后台任务无持久化，进程崩溃丢任务 | 任务中断、无法恢复 | [python.modeling()](backend/app/routers/modeling_router.py:186) 调用 `BackgroundTasks`；[python.run_modeling_task_async()](backend/app/routers/modeling_router.py:238) 在本进程内执行 | 引入任务队列（Redis Streams+Worker/Celery/Arq），支持持久化与重试 | 高 |
| 代理失败/超时无统一失败事件 | 前端无感知、卡死体验 | [python.run_modeling_task_async()](backend/app/routers/modeling_router.py:262) 缺少 try/except；[python.MathModelWorkFlow.execute()](backend/app/core/workflow.py:32) 仅对 Coordinator 局部捕获 | 顶层捕获+错误事件发布+统一重试策略 | 高 |
| Pub/Sub 即时消息易丢 | 进度缺口、刷新后无法补齐 | [python.publish_message()](backend/app/services/redis_manager.py:67) 使用 `publish`；[python.websocket_endpoint()](backend/app/routers/ws_router.py:37) 仅实时消费 | 切换 Redis Streams（保留/回放），或新增“历史拉取”API | 高 |
| 重复“任务开始处理”消息 | 噪声、序列歧义 | [python.run_modeling_task_async()](backend/app/routers/modeling_router.py:253) 与 [python.websocket_endpoint()](backend/app/routers/ws_router.py:31) 均发布 | 仅由后台任务发布；WS 不应二次发布 | 中 |
| 无主任务与清理 | 孤儿任务与大文件堆积 | `work_dir` 持久化但无清理；Redis key 仅 TTL | 任务心跳+超时终止+后台清理器 | 中 |

## 一、后端架构与任务处理

| 问题 | 详述 | 证据（代码/文档） | 触发场景 | 改进建议 | 严重性 |
|---|---|---|---|---|---|
| 使用 `BackgroundTasks` 无持久化 | 后台任务运行依赖当前进程，崩溃/重启即中断，无法恢复进度 | [python.modeling()](backend/app/routers/modeling_router.py:231) `background_tasks.add_task(...)`；[python.run_modeling_task_async()](backend/app/routers/modeling_router.py:238) | 部署滚动更新、容器 OOM、主机重启 | 引入队列：Redis Streams+Worker（自研）或 Celery/Arq。任务入队、Worker 消费、状态持久化（started/running/failed/succeeded），支持重试与幂等 | 高 |
| 代理失败无统一处理 | 仅 Coordinator 有 try/except，其他阶段抛出将直接冒泡至顶层，未发布失败事件 | [python.MathModelWorkFlow.execute()](backend/app/core/workflow.py:46) 仅捕获 Coordinator；[python.run_modeling_task_async()](backend/app/routers/modeling_router.py:262) 无总线级异常处理 | LLM 错误、沙盒报错 | 在 `run_modeling_task_async()` 外围 try/except 捕获 Exception/TimeoutError，发布 `SystemMessage(type='error')`，并写入最终 task_state | 高 |
| 任务超时无专门反馈 | `wait_for` 触发 TimeoutError 未捕获，无“超时”事件 | [python.run_modeling_task_async()](backend/app/routers/modeling_router.py:265) | 子任务长时间阻塞 | 捕获 TimeoutError，发布“超时终止”并执行清理；可配置每阶段超时 | 中 |
| 资源隔离与限额不足 | 沙盒仅配置超时（3000s），未见 CPU/内存/IO 限额，死循环/大内存可拖垮宿主 | [python.create_interpreter(... timeout=3000)](backend/app/core/workflow.py:76)；本地解释器执行用户代码 | 恶意/错误代码 | 使用容器/子进程+资源限额（cgroups/Job Object），设置 per-exec 内存/CPU 限制与输出大小上限；增加抢占式中断 | 高 |
| `md_2_docx` 成功与否未反馈 | 完成消息先于 Docx 转换发送，失败不透明 | [python.run_modeling_task_async()](backend/app/routers/modeling_router.py:268) 与 [python.md_2_docx()](backend/app/routers/modeling_router.py:273) | 文档转换失败 | 将“任务完成”改为“计算完成”；Docx 完成后再发“导出完成”，失败则发 error | 中 |
| 重复“开始处理”消息 | WS 端点在订阅后再次主动发布开始消息 | [python.websocket_endpoint()](backend/app/routers/ws_router.py:31)；后台也发同一消息 [python.run_modeling_task_async()](backend/app/routers/modeling_router.py:253) | 多客户端接入 | 取消 WS 层发布，仅由后台生产 | 低 |

## 二、前后端交互与通信

| 问题 | 详述 | 证据（代码/文档） | 触发场景 | 改进建议 | 严重性 |
|---|---|---|---|---|---|
| 即时 Pub/Sub 丢消息 | 订阅者离线时的消息不可重放，刷新页面后缺口无法补齐 | [python.publish_message()](backend/app/services/redis_manager.py:67)；[python.subscribe_to_task()](backend/app/services/redis_manager.py:83)；[python.websocket_endpoint()](backend/app/routers/ws_router.py:37) | WS 重连、后端短暂重启 | 使用 Redis Streams（XADD/XREADGROUP）替代，维护 `last_id` 游标；或保留现方案并补充“历史消息拉取”API | 高 |
| 历史消息不可恢复 | 虽持久化到文件，但无 API/逻辑回放 | [python._save_message_to_file()](backend/app/services/redis_manager.py:39) 仅写文件；前端未读取 | 刷新 /task/{task_id} | 新增 `GET /tasks/{task_id}/messages` 读取并按时间序列回放；或改用 Streams 原生回放 | 高 |
| 惊群重连与无退避 | 前端不带重连与退避策略；后端短暂不可用将引发同时重连 | [frontend.websocket.connect()](frontend/src/utils/websocket.ts:13) 无重连 | 后端重启/网络抖动 | 前端实现指数退避+抖动、最大重试；后端可加连接速率限制 | 中 |
| 任务存在性校验过于严格 | 仅检查 Redis key，TTL=10h，过期后禁止新连接 | [python.set()](backend/app/services/redis_manager.py:33) `expire(36000)`；[python.websocket_endpoint()](backend/app/routers/ws_router.py:16) | 超长任务/延迟查看 | WS 允许无 key 时以“历史拉取模式”只读接入；或延长 TTL 并在进度消息中刷新 TTL | 低 |

## 三、前端状态与用户体验

| 问题 | 详述 | 证据（代码/文档） | 场景 | 改进建议 | 严重性 |
|---|---|---|---|---|---|
| 刷新后进度丢失 | 仅依赖 WS 实时流，无初始快照 | [frontend.websocket.onmessage()](frontend/src/utils/websocket.ts:18) 只追加 | 刷新任务页 | 页面加载先拉取历史，再接续 WS；消息去重按 `id` | 中 |
| 大块内容渲染可能卡顿 | 代码/论文长文本直接推送前端数组 | [frontend.websocket.onmessage()](frontend/src/utils/websocket.ts:18) | 大模型长输出 | 文本分块/增量渲染、代码折叠、虚拟列表；服务端为大段输出附“摘要+下载” | 中 |
| 操作边界未定义 | 进行中可否重复提交/改参未统一约束 | 文档未体现，代码未见统一状态门控 | 误操作/并发提交 | 以 task_state 驱动 UI：进行中禁用提交/改参，历史只读 | 低 |

## 四、改进路线与优先级

1. 任务持久化与失败可观测（高优先级）
   - 将 [python.run_modeling_task_async()](backend/app/routers/modeling_router.py:238) 迁移到 Worker 模式；引入任务状态表（Redis Hash 或 DB）
   - 在顶层 try/except 捕获异常/超时并发布 `SystemMessage(type='error', code, detail)`
2. 消息可靠与状态恢复（高优先级）
   - 替换 Pub/Sub 为 Streams；或新增 `GET /tasks/{id}/messages` 回放历史（利用 [python._save_message_to_file()](backend/app/services/redis_manager.py:39)）
   - 去除 WS 端重复“开始处理”发布（移除 [python.websocket_endpoint()](backend/app/routers/ws_router.py:31) 的发布）
3. 资源与清理（中优先级）
   - 代码执行进程使用容器/子进程资源限额；为输出与文件大小设上限
   - 后台清理器：扫描 `work_dir` 与 `logs/messages`，按过期策略清理

## 五、诊断假设与验证用日志（请确认）

- 假设A：任务在后端重启后中断且无法恢复。
  - 验证日志：在 [python.run_modeling_task_async()](backend/app/routers/modeling_router.py:238) 启动与每阶段边界点，发布 `event=checkpoint, seq`；重启后对比是否存在“缺口”。
- 假设B：前端刷新存在进度缺口（消息丢失）。
  - 验证日志：在 [python.publish_message()](backend/app/services/redis_manager.py:67) 为每条消息附 `seq` 并落盘；前端记录最后 `seq`，刷新后比对缺失区间。

确认后可按上述优先级执行修复与演进方案。